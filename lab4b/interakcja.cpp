/************************************************************
Interakcja:
Wysy³anie, odbiór komunikatów, interakcja z innymi
uczestnikami WZR, sterowanie wirtualnymi obiektami  
*************************************************************/

#include <windows.h>
#include <time.h>
#include <stdio.h>   
#include "interakcja.h"
#include "obiekty.h"
#include "grafika.h"

#include "siec.h"

FILE *f = fopen("plik_wzr.txt","w");     // plik do zapisu informacji testowych

ObiektRuchomy *pMojObiekt;               // obiekt przypisany do tej aplikacji

Teren teren;
int iLiczbaCudzychOb = 0;
ObiektRuchomy *CudzeObiekty[1000];  // obiekty z innych aplikacji lub inne obiekty niz pMojObiekt
int IndeksyOb[1000];                // tablica indeksow innych obiektow ulatwiajaca wyszukiwanie

float fDt;                          // sredni czas pomiedzy dwoma kolejnymi cyklami symulacji i wyswietlania
long czas_cyklu_WS,licznik_sym;     // zmienne pomocnicze potrzebne do obliczania fDt
float sr_czestosc;                  // srednia czestosc wysylania ramek w [ramkach/s] 
long czas_start = clock();          // czas od poczatku dzialania aplikacji  

multicast_net *multi_reciv;         // wsk do obiektu zajmujacego sie odbiorem komunikatow
multicast_net *multi_send;          //   -||-  wysylaniem komunikatow

HANDLE threadReciv;                 // uchwyt w¹tku odbioru komunikatów
extern HWND okno;       
int SHIFTwcisniety = 0;            

int liczba_prob_podniesienia = 0;

bool is_agent = true;				// czy agent
int agent_target = -1;				// cel agenta, indeks tablicy celów agenta / obiektów terenu
int deny_target = -1;				// zakazany cel


float odleglosc = 10000000.0;
float odlegloscNowa = 0.0;
int index = -1;

// sytuacja I - kupuj¹cy chce kupiæ paliwo i czeka
int id_sprzedawcy = -1;
float ile_sprzedac_paliwa = 0.f;
bool czy_wyslane_potwierdzenie = false;
bool czekaj = false;
bool w_trakcie_realizacji = false;

// sytuacja II - sprzedaj¹cy chce sprzedaæ paliwo i jedzie
bool czekaj_2 = false;

//
float za_jaka_cene_chce_kupic = 0.f;
const float CENA_PALIWA = 10.f;

// Parametry widoku:
Wektor3 kierunek_kamery = Wektor3(10,-3,-11);   // kierunek patrzenia
Wektor3 pol_kamery = Wektor3(-5,3,10);          // po³o¿enie kamery
Wektor3 pion_kamery = Wektor3(0,1,0);           // kierunek pionu kamery             
bool sledzenie = 0;                             // tryb œledzenia obiektu przez kamerê
float oddalenie = 1.0;                          // oddalenie lub przybli¿enie kamery
float zoom = 1.0;                               // zmiana k¹ta widzenia
float kat_kam_z = 0;                            // obrót kamery góra-dó³
bool sterowanie_myszkowe = 0;                   // sterowanie pojazdem za pomoc¹ myszki
int kursor_x, kursor_y;                         // polo¿enie kursora myszki w chwili w³¹czenia sterowania

int opoznienia = 0;                
bool podnoszenie_przedm = 0;        // czy mozna podnosic przedmioty
bool rejestracja_uczestnikow = 1;   // rejestracja trwa do momentu wziêcia przedmiotu przez któregokolwiek uczestnika,
// w przeciwnym razie trzeba by przesy³aæ ca³y stan œrodowiska nowicjuszowi
float czas_odnowy_przedm = 90;      // czas w [s] po którym wziête przedmioty odnawiaj¹ siê
bool czy_umiejetnosci = 0;          // czy zró¿nicowanie umiejêtnoœci (dla ka¿dego pojazdu losowane s¹ umiejêtnoœci
// zbierania gotówki i paliwa)

extern float WyslaniePrzekazu(int ID_adresata, int typ_przekazu, float wartosc_przekazu, float cena_jednostkowa);

enum typy_ramek {STAN_OBIEKTU, WZIECIE_PRZEDMIOTU, ODNOWIENIE_SIE_PRZEDMIOTU, KOLIZJA, PRZEKAZ, 
	PROSBA_O_ZAMKNIECIE, NEGOCJACJE_HANDLOWE, CHEC_KUPNA, CHEC_SPRZEDAZY, POTWIERDZAM_SPRZEDAZ, POTWIERDZAM_KUPNO};

enum typy_przekazu {GOTOWKA, PALIWO};
int typ=0;
struct Ramka
{  
	int typ_ramki;
	long czas_wyslania;    
	int iID_adresata;      // nr ID adresata wiadomoœci (pozostali uczestnicy powinni wiadomoœæ zignorowaæ)

	int nr_przedmiotu;     // nr przedmiotu, który zosta³ wziêty lub odzyskany
	Wektor3 wdV_kolid;     // wektor prêdkoœci wyjœciowej po kolizji (uczestnik o wskazanym adresie powinien 
	// przyj¹æ t¹ prêdkoœæ)  

	int typ_przekazu;        // gotówka, paliwo
	float wartosc_przekazu;  // iloœæ gotówki lub paliwa 
	float cena_przekazu;  // jednostkowa cena przekazu
	int nr_druzyny;

	StanObiektu stan;
};


//******************************************
// Funkcja obs³ugi w¹tku odbioru komunikatów 
DWORD WINAPI WatekOdbioru(void *ptr)
{
	multicast_net *pmt_net=(multicast_net*)ptr;  // wskaŸnik do obiektu klasy multicast_net
	int rozmiar;                                 // liczba bajtów ramki otrzymanej z sieci
	Ramka ramka;
	StanObiektu stan;

	while(1)
	{
		rozmiar = pmt_net->reciv((char*)&ramka,sizeof(Ramka));   // oczekiwanie na nadejœcie ramki 
		switch (ramka.typ_ramki) 
		{
		case STAN_OBIEKTU:           // podstawowy typ ramki informuj¹cej o stanie obiektu              
			{
				stan = ramka.stan;
				//fprintf(f,"odebrano stan iID = %d, ID dla mojego obiektu = %d\n",stan.iID,pMojObiekt->iID);
				int niewlasny = 1;
				if ((stan.iID != pMojObiekt->iID))          // jeœli to nie mój w³asny obiekt
				{

					if ((rejestracja_uczestnikow)&&(IndeksyOb[stan.iID] == -1))        // nie ma jeszcze takiego obiektu w tablicy -> trzeba go stworzyæ
					{
						CudzeObiekty[iLiczbaCudzychOb] = new ObiektRuchomy();   
						IndeksyOb[stan.iID] = iLiczbaCudzychOb;     // wpis do tablicy indeksowanej numerami ID
						// u³atwia wyszukiwanie, alternatyw¹ mo¿e byæ tabl. rozproszona                                                                                                           
						iLiczbaCudzychOb++;     
						CudzeObiekty[IndeksyOb[stan.iID]]->ZmienStan(stan);   // aktualizacja stanu obiektu obcego 			
					}        
					else if (IndeksyOb[stan.iID] != -1)
						CudzeObiekty[IndeksyOb[stan.iID]]->ZmienStan(stan);   // aktualizacja stanu obiektu obcego 	
					else                                                    
					{
						Ramka ramka;
						ramka.typ_ramki = PROSBA_O_ZAMKNIECIE;                // ¿¹danie zamkiêcia aplikacji
						ramka.iID_adresata = stan.iID;
						int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));
					}
				}
				break;
			}
		case WZIECIE_PRZEDMIOTU:            // ramka informuj¹ca, ¿e ktoœ wzi¹³ przedmiot o podanym numerze
			{
				if ((ramka.nr_przedmiotu < teren.liczba_przedmiotow)&&(stan.iID != pMojObiekt->iID))
				{
					teren.p[ramka.nr_przedmiotu].do_wziecia = 0;
					teren.p[ramka.nr_przedmiotu].czy_ja_wzialem = 0;
					rejestracja_uczestnikow = 0;
				}
				break;
			}
		case ODNOWIENIE_SIE_PRZEDMIOTU:       // ramka informujaca, ¿e przedmiot wczeœniej wziêty pojawi³ siê znowu w tym samym miejscu
			{
				if (ramka.nr_przedmiotu < teren.liczba_przedmiotow)
					teren.p[ramka.nr_przedmiotu].do_wziecia = 1;
				break;
			}
		case KOLIZJA:                       // ramka informuj¹ca o tym, ¿e obiekt uleg³ kolizji
			{
				if (ramka.iID_adresata == pMojObiekt->iID)  // ID pojazdu, który uczestniczy³ w kolizji zgadza siê z moim ID 
				{
					pMojObiekt->wdV_kolid = ramka.wdV_kolid; // przepisuje poprawkê w³asnej prêdkoœci
					pMojObiekt->iID_kolid = pMojObiekt->iID; // ustawiam nr. kolidujacego jako w³asny na znak, ¿e powinienem poprawiæ prêdkoœæ
				}
				break;
			}
		case PRZEKAZ:                       // ramka informuj¹ca o przelewie pieniê¿nym lub przekazaniu towaru    
			{
				if (ramka.iID_adresata == pMojObiekt->iID)  // ID pojazdu, ktory otrzymal przelew zgadza siê z moim ID 
				{       
					if (ramka.typ_przekazu == GOTOWKA)
					{
						pMojObiekt->pieniadze += ramka.wartosc_przekazu; 					
						printf("Dostalem pieniadze: %f", ramka.wartosc_przekazu);
					}
					else if (ramka.typ_przekazu == PALIWO)
					{
						pMojObiekt->ilosc_paliwa += ramka.wartosc_przekazu;

						if (czekaj)
						{
							// wys³anie gotówki
							float ilosc_p =  0;
							ilosc_p = WyslaniePrzekazu(id_sprzedawcy, GOTOWKA, ramka.wartosc_przekazu * ramka.cena_przekazu, 0.f);

							if (ilosc_p < 1) {
								printf("Gotowki nie da³o siê przekazaæ, bo byæ mo¿e najbli¿szy obiekt ruchomy znajduje siê zbyt daleko.");
							}
							else {
								printf("przeslalem %f gotowki do obiektu nr %d\n", ilosc_p, ramka.stan.iID);
							}
						}
					}

					// nale¿a³oby jeszcze przelew potwierdziæ (w UDP ramki mog¹ byæ gubione!)
					czekaj = false;
					w_trakcie_realizacji = false;
					czy_wyslane_potwierdzenie = false;
				}
				break;
			}
		case PROSBA_O_ZAMKNIECIE:           // ramka informuj¹ca, ¿e powinieneœ siê zamkn¹æ
			{
				if (ramka.iID_adresata == pMojObiekt->iID)
				{   
					SendMessage(okno,WM_DESTROY,0,100);
				}
				break;
			}
		case CHEC_SPRZEDAZY:
		{
			// sytuacja II
			// perspektywa kupca
			if (pMojObiekt->ilosc_paliwa < 30.f && !czy_wyslane_potwierdzenie) {
				//@todo: doliczanie dojazdu do ceny
				if (ramka.cena_przekazu < CENA_PALIWA)
				{
					za_jaka_cene_chce_kupic = ramka.cena_przekazu;

					Ramka potwierdzam;
					potwierdzam.typ_ramki = CHEC_KUPNA;
					potwierdzam.cena_przekazu = za_jaka_cene_chce_kupic;
					potwierdzam.wartosc_przekazu = ramka.wartosc_przekazu;
					potwierdzam.stan = pMojObiekt->Stan();
					potwierdzam.iID_adresata = ramka.stan.iID;

					int iRozmiar = multi_send->send_delayed((char*)&potwierdzam, sizeof(Ramka));

					printf("Odebralem ramke chce sprzedac\n");
				}

			}
			break;
		}
		case CHEC_KUPNA:
			{
				// perspektywa sprzedawcy
				if (pMojObiekt->ilosc_paliwa - ramka.wartosc_przekazu > 15.f && !w_trakcie_realizacji) {
					//@todo: doliczanie dojazdu do ceny
					printf("czy %d == %d", pMojObiekt->iID, ramka.iID_adresata);
					if (ramka.cena_przekazu > CENA_PALIWA || pMojObiekt->iID == ramka.iID_adresata)
					{
						za_jaka_cene_chce_kupic = ramka.cena_przekazu;

						// utworzenie ramki potwierdzaj¹cej chêæ sprzeda¿y
						Ramka potwierdzam;
						potwierdzam.iID_adresata = ramka.stan.iID;
						potwierdzam.typ_ramki = POTWIERDZAM_SPRZEDAZ;
						potwierdzam.stan = pMojObiekt->Stan(); 

						int iRozmiar = multi_send->send_delayed((char*)&potwierdzam,sizeof(Ramka));

						ile_sprzedac_paliwa = ramka.wartosc_przekazu;
						printf("Odebralem ramke chce kupic\n");

					}

				}
				break;
			}
		case POTWIERDZAM_SPRZEDAZ:
			{
				// perspektywa kupca
				if (ramka.iID_adresata == pMojObiekt->iID && !czy_wyslane_potwierdzenie)
				{
					id_sprzedawcy = ramka.stan.iID;

					// utworzenie ramki potwierdzaj¹cej chêæ sprzeda¿y
					Ramka potwierdzam;
					potwierdzam.iID_adresata = ramka.stan.iID;
					potwierdzam.typ_ramki = POTWIERDZAM_KUPNO;
					potwierdzam.stan = pMojObiekt->Stan(); 

					int iRozmiar = multi_send->send_delayed((char*)&potwierdzam,sizeof(Ramka));

					czy_wyslane_potwierdzenie = true;

					// oczekiwanie na sprzedawcê
					czekaj = true;
					printf("Odebralem ramke potwierdzam sprzedaz\n");
				}
			}
			break;
		case POTWIERDZAM_KUPNO:
		{
			// perspektywa sprzedawcy
			if (ramka.iID_adresata == pMojObiekt->iID && !w_trakcie_realizacji)
			{
				agent_target = ramka.stan.iID;

				w_trakcie_realizacji = true;

				printf("Odebralem ramke potwierdzam kupno\n");
			}
			break;
		}
		case NEGOCJACJE_HANDLOWE:
			{
				// ------------------------------------------------------------------------
				// --------------- MIEJSCE #1 NA NEGOCJACJE HANDLOWE  ---------------------
				// (szczegó³y na stronie w instrukcji do zadania)




				// ------------------------------------------------------------------------

				break;
			}

		} // switch po typach ramek
	}  // while(1)
	return 1;
}

// *****************************************************************
// ****    Wszystko co trzeba zrobiæ podczas uruchamiania aplikacji
// ****    poza grafik¹   
void PoczatekInterakcji()
{
	DWORD dwThreadId;

	pMojObiekt = new ObiektRuchomy();    // tworzenie wlasnego obiektu

	for (long i=0;i<1000;i++)            // inicjacja indeksow obcych obiektow
		IndeksyOb[i] = -1;

	czas_cyklu_WS = clock();             // pomiar aktualnego czasu

	// obiekty sieciowe typu multicast (z podaniem adresu WZR oraz numeru portu)
	multi_reciv = new multicast_net("192.168.0.3",10001);      // obiekt do odbioru ramek sieciowych
	multi_send = new multicast_net("192.168.0.2",10001);       // obiekt do wysy³ania ramek

	if (opoznienia)
	{
		float srednie_opoznienie = 3*(float)rand()/RAND_MAX, wariancja_opoznienia = 2;
		multi_send->PrepareDelay(srednie_opoznienie,wariancja_opoznienia);
	}

	// uruchomienie watku obslugujacego odbior komunikatow
	threadReciv = CreateThread(
		NULL,                        // no security attributes
		0,                           // use default stack size
		WatekOdbioru,                // thread function
		(void *)multi_reciv,               // argument to thread function
		0,                           // use default creation flags
		&dwThreadId);                // returns the thread identifier

}


// *****************************************************************
// ****    Wszystko co trzeba zrobiæ w ka¿dym cyklu dzia³ania 
// ****    aplikacji poza grafik¹ 
void Cykl_WS()
{
	licznik_sym++;  

	// obliczenie œredniego czasu pomiêdzy dwoma kolejnnymi symulacjami po to, by zachowaæ  fizycznych 
	if (licznik_sym % 50 == 0)          // jeœli licznik cykli przekroczy³ pewn¹ wartoœæ, to
	{                                   // nale¿y na nowo obliczyæ œredni czas cyklu fDt
		char text[200];
		long czas_pop = czas_cyklu_WS;
		czas_cyklu_WS = clock();
		float fFps = (50*CLOCKS_PER_SEC)/(float)(czas_cyklu_WS-czas_pop);
		if (fFps!=0) fDt=1.0/fFps; else fDt=1;

		sprintf(text,"[%d], %0.0f fps  %0.2fms, paliwo = %0.2f, gotowka = %d, F1-pomoc",pMojObiekt->iID, fFps,1000.0/fFps,pMojObiekt->ilosc_paliwa,pMojObiekt->pieniadze);
		SetWindowText(okno,text); // wyœwietlenie aktualnej iloœci klatek/s w pasku okna			
	}   

	pMojObiekt->Symulacja(fDt);                    // symulacja w³asnego obiektu


	if ((pMojObiekt->iID_kolid > -1)&&             // wykryto kolizjê - wysy³am specjaln¹ ramkê, by poinformowaæ o tym drugiego uczestnika
		(pMojObiekt->iID_kolid != pMojObiekt->iID)) // oczywiœcie wtedy, gdy nie chodzi o mój pojazd
	{
		Ramka ramka;
		ramka.typ_ramki = KOLIZJA;
		ramka.iID_adresata = pMojObiekt->iID_kolid;
		ramka.wdV_kolid = pMojObiekt->wdV_kolid;
		int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));

		char text[128];
		sprintf(text,"Kolizja z obiektem o ID = %d",pMojObiekt->iID_kolid);
		SetWindowText(okno,text);

		pMojObiekt->iID_kolid = -1;
	}

	// wyslanie komunikatu o stanie obiektu przypisanego do aplikacji (pMojObiekt):    
	if (licznik_sym % 1 == 0)      
	{
		Ramka ramka;
		ramka.typ_ramki = STAN_OBIEKTU;
		ramka.stan = pMojObiekt->Stan();         // stan w³asnego obiektu 
		int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));
	} 

	long czas_akt = clock();

	// sprawdzam, czy nie najecha³em na monetê lub beczkê z paliwem. Jeœli tak, to zdobywam pieni¹dze lub paliwo oraz wysy³am innym uczestnikom 
	// informacjê o zabraniu beczki: (wczeœniej trzeba wcisn¹æ P) 
	for (long i=0;i<teren.liczba_przedmiotow;i++)
	{
		if ((teren.p[i].do_wziecia == 1)&&(podnoszenie_przedm)&&
			((teren.p[i].wPol - pMojObiekt->wPol + Wektor3(0,pMojObiekt->wPol.y - teren.p[i].wPol.y,0)).dlugosc() < pMojObiekt->promien))
		{

			long wartosc = teren.p[i].wartosc;

			if (teren.p[i].typ == MONETA)
			{
				if (czy_umiejetnosci)
					wartosc = (long)(float)wartosc*pMojObiekt->umiejetn_zb_monet;   
				pMojObiekt->pieniadze += wartosc;   
			}
			else
			{
				if (czy_umiejetnosci)
					wartosc = (float)wartosc*pMojObiekt->umiejetn_zb_paliwa; 
				pMojObiekt->ilosc_paliwa += wartosc;      
			}

			agent_target = -1;
			odleglosc = 10000000.0;
			teren.p[i].do_wziecia = 0;
			teren.p[i].czy_ja_wzialem = 1;
			teren.p[i].czas_wziecia = clock();
			rejestracja_uczestnikow = 0;     // koniec rejestracji nowych uczestników
			liczba_prob_podniesienia = 0;
			deny_target = -1;

			Ramka ramka;
			ramka.typ_ramki = WZIECIE_PRZEDMIOTU; 
			ramka.nr_przedmiotu = i;
			ramka.stan = pMojObiekt->Stan(); 
			int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));
		}
		else if ((teren.p[i].do_wziecia == 0)&&(teren.p[i].czy_ja_wzialem)&&(teren.p[i].czy_odnawialny)&&
			(czas_akt - teren.p[i].czas_wziecia >= czas_odnowy_przedm*CLOCKS_PER_SEC))
		{                              // jeœli min¹³ pewnien okres czasu przedmiot mo¿e zostaæ przywrócony
			teren.p[i].do_wziecia = 1;
			Ramka ramka;
			ramka.typ_ramki = ODNOWIENIE_SIE_PRZEDMIOTU; 
			ramka.nr_przedmiotu = i;
			int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));
		}
	} // for po przedmiotach

	// --------------------------------------------------------------------
	// --------------- MIEJSCE NA ALGORYTM STEROWANIA ---------------------
	// (dobór si³y F w granicach (-2000 N, 4000 N), k¹ta skrêtu kó³ alfa (-pi/4, pi/4) oraz
	// decyzji o hamowaniu ham w zale¿noœci od sytuacji)



	if(is_agent)
	{
		//if (agent_target == -1)
		//{
		// for(int i =0; i< teren.liczba_przedmiotow; i++)
		// {
		//  if(pMojObiekt->ilosc_paliwa < 19.0)
		//	  typ = PALIWO;
		//  else
		//	  typ = MONETA;
		//  if(teren.p[i].typ == typ && teren.p[i].do_wziecia)
		//  {		  
		//	  odlegloscNowa = (teren.p[i].wPol - pMojObiekt->wPol + Wektor3(0,pMojObiekt->wPol.y - teren.p[i].wPol.y,0)).dlugosc();
		//	  if(odleglosc > odlegloscNowa)
		//	  {
		//		  odleglosc = odlegloscNowa;
		//		  index = i;
		//	  }
		//  }
		// }
		// agent_target = index;		 
		// printf("Index obiektu: %d, wartosc: %d\n", index, teren.p[index].wartosc);

		//}

		if (czekaj)
		{
			// perspektywa kupca
			if (licznik_sym % 50 == 0)
			{
				printf("czekam\n");

				if (!czy_wyslane_potwierdzenie) {
					// kupiec
					float ile = 5.f;
					za_jaka_cene_chce_kupic = CENA_PALIWA + 5.f;
					//czy_wyslane_potwierdzenie = false;

					Ramka potwierdzam;
					potwierdzam.typ_ramki = CHEC_KUPNA;
					potwierdzam.cena_przekazu = za_jaka_cene_chce_kupic;
					potwierdzam.wartosc_przekazu = ile;
					potwierdzam.stan = pMojObiekt->Stan();

					int iRozmiar = multi_send->send_delayed((char*)&potwierdzam, sizeof(Ramka));
				}
			}

			if (pMojObiekt->wV.dlugosc() > 3.0)
			{
				pMojObiekt->F= -3000.0;
			}
			else if (pMojObiekt->wV.dlugosc() > 0.5)
			{
				pMojObiekt->F= -1000.0;
			}
			else
			{
				pMojObiekt->F = 0;
				pMojObiekt->wV = Wektor3(0,0,0);
			}


		}
		else if (w_trakcie_realizacji)
		{
			// perspektywa sprzedawcy
			ObiektRuchomy * kupujacy = CudzeObiekty[IndeksyOb[agent_target]];
			Wektor3 t = kupujacy->wPol-pMojObiekt->wPol;
			Wektor3 w_przod = pMojObiekt->qOrient.obroc_wektor(Wektor3(1,0,0)); 

			float cos = (t^w_przod)/(t.dlugosc()*w_przod.dlugosc());
			float kat = acos(cos);

			if(cos > 0.95)
			{
				pMojObiekt->alfa = 0;
			}
			else
			{
				if(kat<PI)		  
					pMojObiekt->alfa = -PI/3;
				else
					pMojObiekt->alfa = +PI/3;
			}

			if (pMojObiekt->wV.dlugosc() < 8.0)
				pMojObiekt->F=1500.0;
			else
				pMojObiekt->F=0.0;

			if((kupujacy->wPol - pMojObiekt->wPol + Wektor3(0,pMojObiekt->wPol.y - kupujacy->wPol.y,0)).dlugosc() < 5.0*pMojObiekt->promien)
			{
				//printf("Predkosc: %f\n", pMojObiekt->wV.dlugosc());

				if (pMojObiekt->wV.dlugosc() > 3.0)
					pMojObiekt->F = -3000.0;
				else if (pMojObiekt->wV.dlugosc() < 1.0)
				{
					pMojObiekt->F = 0;
				}

				float ilosc_p =  0;
				ilosc_p = WyslaniePrzekazu(kupujacy->iID, PALIWO, ile_sprzedac_paliwa, za_jaka_cene_chce_kupic);
				
				
				if (ilosc_p < 1.0) 
				{
					printf("Paliwa nie da³o siê przekazaæ, bo byæ mo¿e najbli¿szy obiekt ruchomy znajduje siê zbyt daleko.\n");
				}
				else
				{
					printf("Wyslalem: %f\n", ile_sprzedac_paliwa);
					w_trakcie_realizacji = false;
					agent_target=-1;
				}
			}

			if (licznik_sym % 50 == 0)
			{
				printf("Predkosc: %f, kat %f, cos %f\n", pMojObiekt->wV.dlugosc(), kat, cos);
			}
		}
		else if (agent_target >= 0 && teren.p[agent_target].do_wziecia)
		{

			Wektor3 t = teren.p[agent_target].wPol-pMojObiekt->wPol;
			Wektor3 w_przod = pMojObiekt->qOrient.obroc_wektor(Wektor3(1,0,0)); 

			float cos = (t^w_przod)/(t.dlugosc()*w_przod.dlugosc());
			float kat = acos(cos);

			if(cos > 0.95)
			{
				pMojObiekt->alfa = 0;
			}
			else
			{
				if(kat<PI)		  
					pMojObiekt->alfa = -PI/2-.1f;
				else
					pMojObiekt->alfa = +PI/2-.1f;
			}

			if (pMojObiekt->wV.dlugosc() < 8.0)
				pMojObiekt->F=1500.0;
			else
				pMojObiekt->F=0.0;

			if((teren.p[agent_target].wPol - pMojObiekt->wPol + Wektor3(0,pMojObiekt->wPol.y - teren.p[agent_target].wPol.y,0)).dlugosc() < 5.0*pMojObiekt->promien)
			{
				//printf("Predkosc: %f\n", pMojObiekt->wV.dlugosc());

				if(pMojObiekt->wV.dlugosc() > 3.0)
					pMojObiekt->F= -1500.0;

				podnoszenie_przedm = 1;
				++liczba_prob_podniesienia;

				if (liczba_prob_podniesienia > 1000) {
					deny_target = agent_target;
					agent_target = -1;
				}
			}
			else
			{
				podnoszenie_przedm = 0;
			}

			if (licznik_sym % 50 == 0)
			{
				printf("Predkosc: %f, kat %f, cos %f, liczba prob %d\n", pMojObiekt->wV.dlugosc(), kat, cos, liczba_prob_podniesienia);
			}
		}
		else
		{
			agent_target = -1;
			odleglosc = 10000000.0;

			// jeœli mam za du¿o paliwo, to sprzedaj
			if (pMojObiekt->ilosc_paliwa > 100.f) 
			{
				if (licznik_sym % 50 == 0)
				{
					float nasza_cena = CENA_PALIWA - 5.f;
					czy_wyslane_potwierdzenie = false;

					ile_sprzedac_paliwa = 10.f;

					Ramka potwierdzam;
					potwierdzam.typ_ramki = CHEC_SPRZEDAZY;
					potwierdzam.cena_przekazu = nasza_cena;
					potwierdzam.wartosc_przekazu = ile_sprzedac_paliwa;
					potwierdzam.stan = pMojObiekt->Stan();

					int iRozmiar = multi_send->send_delayed((char*)&potwierdzam, sizeof(Ramka));

					printf("chce sprzedac %f paliwa za %f\n", ile_sprzedac_paliwa, nasza_cena);
				}

			}
			// jesli mam za malo paliwo, to kup
			else if (pMojObiekt->ilosc_paliwa < 10.f)
			{
				// kupiec
				float ile = 5.f;
				za_jaka_cene_chce_kupic = CENA_PALIWA + 5.f;
				czy_wyslane_potwierdzenie = false;

				Ramka potwierdzam;
				potwierdzam.typ_ramki = CHEC_KUPNA;
				potwierdzam.cena_przekazu = za_jaka_cene_chce_kupic;
				potwierdzam.wartosc_przekazu = ile;
				potwierdzam.stan = pMojObiekt->Stan(); 

				int iRozmiar = multi_send->send_delayed((char*)&potwierdzam, sizeof(Ramka));

				printf("chce kupic %f paliwa za %f\n", ile, za_jaka_cene_chce_kupic);

				czekaj = true;
			} else {
				// w przeciwnym razie zbieraj dalej

				for(int i =0; i< teren.liczba_przedmiotow; i++)
				{
					if(pMojObiekt->ilosc_paliwa < 150.0)
						typ = PALIWO;
					else
						typ = MONETA;
					if(teren.p[i].typ == typ && teren.p[i].do_wziecia)
					{		  
						odlegloscNowa = (teren.p[i].wPol - pMojObiekt->wPol + Wektor3(0,pMojObiekt->wPol.y - teren.p[i].wPol.y,0)).dlugosc();
						if(odleglosc > odlegloscNowa && i != deny_target)
						{
							odleglosc = odlegloscNowa;
							index = i;
						}
					}
				}
			}

			agent_target = index;

			if (agent_target >= 0)
				printf("Index obiektu: %d, wartosc: %d, do wziêcia: %d\n", index, teren.p[index].wartosc, teren.p[index].do_wziecia);
		}
	}

	// --------------------------------------------------------------------


	// ------------------------------------------------------------------------
	// --------------- MIEJSCE #2 NA NEGOCJACJE HANDLOWE  ---------------------
	// (szczegó³y na stronie w instrukcji do zadania)




	// ------------------------------------------------------------------------
}

// *****************************************************************
// ****    Wszystko co trzeba zrobiæ podczas zamykania aplikacji
// ****    poza grafik¹ 
void ZakonczenieInterakcji()
{
	fprintf(f,"Koniec interakcji\n");
	fclose(f);
}

// Funkcja wysylajaca ramke z przekazem, zwraca zrealizowan¹ wartoœæ przekazu
float WyslaniePrzekazu(int ID_adresata, int typ_przekazu, float wartosc_przekazu, float cena_jednostkowa)
{
	Ramka ramka;
	ramka.typ_ramki = PRZEKAZ;
	ramka.iID_adresata = ID_adresata;
	ramka.typ_przekazu = typ_przekazu;
	ramka.wartosc_przekazu = wartosc_przekazu;
	ramka.cena_przekazu = cena_jednostkowa;

	// tutaj nale¿a³oby uzyskaæ potwierdzenie przekazu zanim sumy zostan¹ odjête
	if (typ_przekazu == GOTOWKA)
	{
		if (pMojObiekt->pieniadze < wartosc_przekazu) 
			ramka.wartosc_przekazu = pMojObiekt->pieniadze;
		pMojObiekt->pieniadze -= ramka.wartosc_przekazu;
	}
	else if (typ_przekazu == PALIWO)
	{
		// odszukanie adresata, sprawdzenie czy jest odpowiednio blisko:
		int indeks_adresata = -1;
		for (int i=0;i<iLiczbaCudzychOb;i++)
			if (CudzeObiekty[i]->iID == ID_adresata) {indeks_adresata = i; break;}
			if ((CudzeObiekty[indeks_adresata]->wPol - pMojObiekt->wPol).dlugosc() > 
				CudzeObiekty[indeks_adresata]->dlugosc + pMojObiekt->dlugosc)
				ramka.wartosc_przekazu = 0;
			else
			{
				if (pMojObiekt->ilosc_paliwa < wartosc_przekazu)
					ramka.wartosc_przekazu = pMojObiekt->ilosc_paliwa;
				pMojObiekt->ilosc_paliwa -= ramka.wartosc_przekazu; 
			}
	}

	if (ramka.wartosc_przekazu > 0)
		int iRozmiar = multi_send->send_delayed((char*)&ramka,sizeof(Ramka));  

	return ramka.wartosc_przekazu;
}


// ************************************************************************
// ****    Obs³uga klawiszy s³u¿¹cych do sterowania obiektami lub
// ****    widokami 
void KlawiszologiaSterowania(UINT kod_meldunku, WPARAM wParam, LPARAM lParam)
{

	switch (kod_meldunku) 
	{

	case WM_LBUTTONDOWN: //reakcja na lewy przycisk myszki
		{
			int x = LOWORD(lParam);
			int y = HIWORD(lParam);
			if (sterowanie_myszkowe)
				pMojObiekt->F = 4100.0;        // si³a pchaj¹ca do przodu
			break;
		}
	case WM_RBUTTONDOWN: //reakcja na prawy przycisk myszki
		{
			int x = LOWORD(lParam);
			int y = HIWORD(lParam);
			if (sterowanie_myszkowe)
				pMojObiekt->F = -2100.0;        // si³a pchaj¹ca do tylu
			break;
		}
	case WM_MBUTTONDOWN: //reakcja na œrodkowy przycisk myszki : uaktywnienie/dezaktywacja sterwania myszkowego
		{
			sterowanie_myszkowe = 1 - sterowanie_myszkowe;
			kursor_x = LOWORD(lParam);
			kursor_y = HIWORD(lParam);
			break;
		}
	case WM_LBUTTONUP: //reakcja na puszczenie lewego przycisku myszki
		{   
			if (sterowanie_myszkowe)
				pMojObiekt->F = 0.0;        // si³a pchaj¹ca do przodu
			break;
		}
	case WM_RBUTTONUP: //reakcja na puszczenie lewy przycisk myszki
		{
			if (sterowanie_myszkowe)
				pMojObiekt->F = 0.0;        // si³a pchaj¹ca do przodu
			break;
		}
	case WM_MOUSEMOVE:
		{
			int x = LOWORD(lParam);
			int y = HIWORD(lParam);
			if (sterowanie_myszkowe)
			{
				float kat_skretu = (float)(kursor_x - x)/20;
				if (kat_skretu > 45) kat_skretu = 45;
				if (kat_skretu < -45) kat_skretu = -45;	
				pMojObiekt->alfa = PI*kat_skretu/180;
			}
			break;
		}
	case WM_KEYDOWN:
		{

			switch (LOWORD(wParam))
			{
			case VK_SHIFT:
				{
					SHIFTwcisniety = 1; 
					break; 
				}        
			case VK_SPACE:
				{
					pMojObiekt->ham = 1.0;       // stopieñ hamowania (reszta zale¿y od si³y docisku i wsp. tarcia)
					break;                       // 1.0 to maksymalny stopieñ (np. zablokowanie kó³)
				}
			case VK_UP:
				{

					pMojObiekt->F = 4100.0;        // si³a pchaj¹ca do przodu
					break;
				}
			case VK_DOWN:
				{
					pMojObiekt->F = -2100.0;        // sila pchajaca do tylu
					break;
				}
			case VK_LEFT:
				{
					if (SHIFTwcisniety) pMojObiekt->alfa = PI*35/180;
					else pMojObiekt->alfa = PI*15/180;

					break;
				}
			case VK_RIGHT:
				{
					if (SHIFTwcisniety) pMojObiekt->alfa = -PI*35/180;
					else pMojObiekt->alfa = -PI*15/180;
					break;
				}
			case 'W':   // przybli¿enie widoku
				{
					//pol_kamery = pol_kamery - kierunek_kamery*0.3;
					if (oddalenie > 0.5) oddalenie /= 1.2;
					else oddalenie = 0;  
					break; 
				}     
			case 'S':   // oddalenie widoku
				{
					//pol_kamery = pol_kamery + kierunek_kamery*0.3; 
					if (oddalenie > 0) oddalenie *= 1.2;
					else oddalenie = 0.5;   
					break; 
				}    
			case 'Q':   // widok z góry
				{
					pol_kamery = Wektor3(0,100,0);
					kierunek_kamery = Wektor3(0,-1,0.01);
					pion_kamery = Wektor3(0,0,-1);
					break;
				}
			case 'E':   // obrót kamery ku górze (wzglêdem lokalnej osi z)
				{
					kat_kam_z += PI*5/180; 
					break; 
				}    
			case 'D':   // obrót kamery ku do³owi (wzglêdem lokalnej osi z)
				{
					kat_kam_z -= PI*5/180;  
					break;
				}
			case 'A':   // w³¹czanie, wy³¹czanie trybu œledzenia obiektu
				{
					sledzenie = 1 - sledzenie;
					break;
				}
			case 'Z':   // zoom - zmniejszenie k¹ta widzenia
				{
					zoom /= 1.1;
					RECT rc;
					GetClientRect (okno, &rc);
					ZmianaRozmiaruOkna(rc.right - rc.left,rc.bottom-rc.top);
					break;
				}
			case 'X':   // zoom - zwiêkszenie k¹ta widzenia
				{
					zoom *= 1.1;
					RECT rc;
					GetClientRect (okno, &rc);
					ZmianaRozmiaruOkna(rc.right - rc.left,rc.bottom-rc.top);
					break;
				}
			case 'P':   // podnoszenie przedmiotów
				{
					//Wektor3 w_przod = pMojObiekt->qOrient.obroc_wektor(Wektor3(1,0,0));
					//+ Wector3(0,pMojObiekt->wPol.y - teren.p[i].wPol.y,0)
					podnoszenie_przedm = 1 - podnoszenie_przedm;
					break;
				}
			case 'F':  // przekazanie 10 kg paliwa pojazdowi, który znajduje siê najbli¿ej
				{
					float min_odleglosc = 1e10;
					int indeks_min = -1;
					for (int i=0;i<iLiczbaCudzychOb;i++)
					{
						if (min_odleglosc > (CudzeObiekty[i]->wPol - pMojObiekt->wPol).dlugosc() )
						{
							min_odleglosc = (CudzeObiekty[i]->wPol - pMojObiekt->wPol).dlugosc();
							indeks_min = i;
						}
					}

					float ilosc_p =  0;
					if (indeks_min > -1)
						ilosc_p = WyslaniePrzekazu(CudzeObiekty[indeks_min]->iID, PALIWO, 10, 0.f);

					if (ilosc_p == 0) 
						MessageBox(okno,"Paliwa nie da³o siê przekazaæ, bo byæ mo¿e najbli¿szy obiekt ruchomy znajduje siê zbyt daleko.",
						"Nie da³o siê przekazaæ paliwa!",MB_OK);
					break;
				}
			case 'G':  // przekazanie 100 jednostek gotowki pojazdowi, który znajduje siê najbli¿ej
				{
					float min_odleglosc = 1e10;
					int indeks_min = -1;
					for (int i=0;i<iLiczbaCudzychOb;i++)
					{
						if (min_odleglosc > (CudzeObiekty[i]->wPol - pMojObiekt->wPol).dlugosc() )
						{
							min_odleglosc = (CudzeObiekty[i]->wPol - pMojObiekt->wPol).dlugosc();
							indeks_min = i;
						}
					}

					float ilosc_p =  0;
					if (indeks_min > -1)
						ilosc_p = WyslaniePrzekazu(CudzeObiekty[indeks_min]->iID, GOTOWKA, 100, 0.f);

					if (ilosc_p == 0) 
						MessageBox(okno,"Gotówki nie da³o siê przekazaæ, bo byæ mo¿e najbli¿szy obiekt ruchomy znajduje siê zbyt daleko.",
						"Nie da³o siê przekazaæ gotówki!",MB_OK);
					break;
				}
			} // switch po klawiszach

			break;
		}
	case WM_KEYUP:
		{
			switch (LOWORD(wParam))
			{
			case VK_SHIFT:
				{
					SHIFTwcisniety = 0; 
					break; 
				}        
			case VK_SPACE:
				{
					pMojObiekt->ham = 0.0;
					break;
				}
			case VK_UP:
				{
					pMojObiekt->F = 0.0;

					break;
				}
			case VK_DOWN:
				{
					pMojObiekt->F = 0.0;
					break;
				}
			case VK_LEFT:
				{
					pMojObiekt->Fb = 0.00;
					pMojObiekt->alfa = 0;	
					break;
				}
			case VK_RIGHT:
				{
					pMojObiekt->Fb = 0.00;
					pMojObiekt->alfa = 0;	
					break;
				}

			}

			break;
		}

	} // switch po komunikatach
}
